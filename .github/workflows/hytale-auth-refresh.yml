name: Hytale Auth Token Refresh

on:
  # Run every 30 minutes
  schedule:
    - cron: "*/30 * * * *"
  
  # Manual trigger
  workflow_dispatch:
    inputs:
      mode:
        description: "Mode: 'device_code' for initial auth, 'refresh' to refresh existing tokens"
        required: true
        type: choice
        options:
          - refresh
          - device_code
        default: refresh
      hytale_access_token:
        description: "Hytale Access Token (for manual token input)"
        required: false
        type: string
      hytale_refresh_token:
        description: "Hytale Refresh Token (for manual token input)"
        required: false
        type: string
      force_rebuild:
        description: "Force rebuild hytale-auth container"
        required: false
        type: boolean
        default: true

jobs:
  refresh-auth:
    name: "Refresh Hytale Authentication"
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4

      - name: Device Code Flow - Request Code
        if: inputs.mode == 'device_code' && github.event_name == 'workflow_dispatch'
        id: device_code
        run: |
          echo "ðŸ” Starting Device Code Flow for initial authentication..."
          
          # Step 1: Request device code
          RESPONSE=$(curl -s -X POST "https://oauth.accounts.hytale.com/oauth2/device/auth" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "client_id=hytale-server" \
            -d "scope=openid offline auth:server")
          
          DEVICE_CODE=$(echo "$RESPONSE" | jq -r '.device_code')
          USER_CODE=$(echo "$RESPONSE" | jq -r '.user_code')
          VERIFICATION_URI=$(echo "$RESPONSE" | jq -r '.verification_uri_complete')
          EXPIRES_IN=$(echo "$RESPONSE" | jq -r '.expires_in')
          INTERVAL=$(echo "$RESPONSE" | jq -r '.interval')
          
          echo "device_code=$DEVICE_CODE" >> $GITHUB_OUTPUT
          echo "interval=$INTERVAL" >> $GITHUB_OUTPUT
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ” Device Authorization Required" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Please visit the following URL to authorize:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### $VERIFICATION_URI" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**User Code:** \`$USER_CODE\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "This code expires in $EXPIRES_IN seconds ($(($EXPIRES_IN / 60)) minutes)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          
          echo "â³ Please authorize at: $VERIFICATION_URI"
          echo "ðŸ“‹ User Code: $USER_CODE"
          echo "â±ï¸  Expires in: $EXPIRES_IN seconds"

      - name: Device Code Flow - Wait for Authorization
        if: inputs.mode == 'device_code' && github.event_name == 'workflow_dispatch'
        id: device_auth
        run: |
          echo "â³ Waiting for user authorization..."
          
          DEVICE_CODE="${{ steps.device_code.outputs.device_code }}"
          INTERVAL=${{ steps.device_code.outputs.interval }}
          MAX_ATTEMPTS=180  # 15 minutes max (180 * 5 seconds)
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            sleep $INTERVAL
            
            RESPONSE=$(curl -s -X POST "https://oauth.accounts.hytale.com/oauth2/token" \
              -H "Content-Type: application/x-www-form-urlencoded" \
              -d "client_id=hytale-server" \
              -d "grant_type=urn:ietf:params:oauth:grant-type:device_code" \
              -d "device_code=$DEVICE_CODE")
            
            # Check for errors
            ERROR=$(echo "$RESPONSE" | jq -r '.error // ""')
            
            if [ "$ERROR" == "authorization_pending" ]; then
              echo "â³ Still waiting... (attempt $ATTEMPT/$MAX_ATTEMPTS)"
              continue
            elif [ "$ERROR" == "slow_down" ]; then
              echo "âš ï¸  Slowing down polling rate"
              INTERVAL=$((INTERVAL + 5))
              continue
            elif [ -n "$ERROR" ] && [ "$ERROR" != "null" ]; then
              echo "âŒ Authorization failed: $ERROR"
              echo "$RESPONSE" | jq '.'
              exit 1
            fi
            
            # Success! Extract tokens
            ACCESS_TOKEN=$(echo "$RESPONSE" | jq -r '.access_token')
            REFRESH_TOKEN=$(echo "$RESPONSE" | jq -r '.refresh_token')
            
            if [ -n "$ACCESS_TOKEN" ] && [ "$ACCESS_TOKEN" != "null" ]; then
              echo "device_access_token=$ACCESS_TOKEN" >> $GITHUB_OUTPUT
              echo "device_refresh_token=$REFRESH_TOKEN" >> $GITHUB_OUTPUT
              echo "âœ… Authorization successful!"
              exit 0
            fi
          done
          
          echo "âŒ Authorization timeout - user did not complete authorization in time"
          exit 1

      - name: Setup Authentication
        id: setup_auth
        run: |
          # Priority: device_code > manual input > stored secrets
          # Scheduled runs always use stored secrets
          if [ "${{ github.event_name }}" == "schedule" ]; then
            echo "Using stored tokens from secrets (scheduled run)"
            ACCESS_TOKEN="${{ secrets.HYTALE_ACCESS_TOKEN }}"
            REFRESH_TOKEN="${{ secrets.HYTALE_REFRESH_TOKEN }}"
          elif [ "${{ inputs.mode }}" == "device_code" ]; then
            echo "Using tokens from device code flow"
            ACCESS_TOKEN="${{ steps.device_auth.outputs.device_access_token }}"
            REFRESH_TOKEN="${{ steps.device_auth.outputs.device_refresh_token }}"
          elif [ -n "${{ inputs.hytale_access_token }}" ]; then
            echo "Using manually provided tokens"
            ACCESS_TOKEN="${{ inputs.hytale_access_token }}"
            REFRESH_TOKEN="${{ inputs.hytale_refresh_token }}"
          else
            echo "Using stored tokens from secrets"
            ACCESS_TOKEN="${{ secrets.HYTALE_ACCESS_TOKEN }}"
            REFRESH_TOKEN="${{ secrets.HYTALE_REFRESH_TOKEN }}"
          fi

          echo "access_token=$ACCESS_TOKEN" >> $GITHUB_OUTPUT
          echo "refresh_token=$REFRESH_TOKEN" >> $GITHUB_OUTPUT

      - name: Refresh OAuth2 Access Token
        if: github.event_name == 'schedule' || inputs.mode == 'refresh'
        id: refresh_token
        run: |
          echo "ðŸ”„ Refreshing OAuth2 access token using refresh_token grant..."

          # Use OAuth2 refresh token flow per Hytale documentation
          # https://support.hytale.com/hc/en-us/articles/45328341414043-Server-Provider-Authentication-Guide
          RESPONSE=$(curl -s -X POST "https://oauth.accounts.hytale.com/oauth2/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "client_id=hytale-server" \
            -d "grant_type=refresh_token" \
            -d "refresh_token=${{ steps.setup_auth.outputs.refresh_token }}")

          # Check if refresh was successful
          if echo "$RESPONSE" | jq -e '.error' >/dev/null 2>&1; then
            ERROR=$(echo "$RESPONSE" | jq -r '.error')
            ERROR_DESC=$(echo "$RESPONSE" | jq -r '.error_description // "No description provided"')
            echo "âŒ Token refresh failed: $ERROR - $ERROR_DESC"
            exit 1
          fi

          # Extract new tokens
          NEW_ACCESS_TOKEN=$(echo "$RESPONSE" | jq -r '.access_token')
          NEW_REFRESH_TOKEN=$(echo "$RESPONSE" | jq -r '.refresh_token // ""')
          EXPIRES_IN=$(echo "$RESPONSE" | jq -r '.expires_in')

          # Use existing refresh token if new one wasn't provided
          if [ -z "$NEW_REFRESH_TOKEN" ] || [ "$NEW_REFRESH_TOKEN" == "null" ]; then
            NEW_REFRESH_TOKEN="${{ steps.setup_auth.outputs.refresh_token }}"
            echo "â„¹ï¸  Keeping existing refresh token (new one not provided)"
          fi

          echo "new_access_token=$NEW_ACCESS_TOKEN" >> $GITHUB_OUTPUT
          echo "new_refresh_token=$NEW_REFRESH_TOKEN" >> $GITHUB_OUTPUT
          echo "âœ… Access token refreshed successfully! (expires in ${EXPIRES_IN}s)"

      - name: Update GitHub Secrets
        if: (github.event_name == 'schedule' || inputs.mode == 'refresh') && steps.refresh_token.outputs.new_access_token != '' || inputs.mode == 'device_code'
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
          NEW_ACCESS_TOKEN: ${{ inputs.mode == 'device_code' && steps.setup_auth.outputs.access_token || steps.refresh_token.outputs.new_access_token }}
          NEW_REFRESH_TOKEN: ${{ inputs.mode == 'device_code' && steps.setup_auth.outputs.refresh_token || steps.refresh_token.outputs.new_refresh_token }}
        run: |
          # Update HYTALE_ACCESS_TOKEN secret using GitHub CLI
          echo "Updating HYTALE_ACCESS_TOKEN secret..."
          echo "$NEW_ACCESS_TOKEN" | gh secret set HYTALE_ACCESS_TOKEN --repo ${{ github.repository }}

          # Update HYTALE_REFRESH_TOKEN secret if it exists
          if [ -n "$NEW_REFRESH_TOKEN" ]; then
            echo "Updating HYTALE_REFRESH_TOKEN secret..."
            echo "$NEW_REFRESH_TOKEN" | gh secret set HYTALE_REFRESH_TOKEN --repo ${{ github.repository }}
          fi

          echo "âœ… GitHub secrets updated successfully!"

      - name: Check Hytale Version
        id: check_version
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          echo "ðŸ” Checking current Hytale server version..."
          
          # Get current access token
          if [ "${{ github.event_name }}" == "schedule" ] || [ "${{ inputs.mode }}" == "refresh" ]; then
            ACCESS_TOKEN="${{ steps.refresh_token.outputs.new_access_token }}"
          else
            ACCESS_TOKEN="${{ steps.setup_auth.outputs.access_token }}"
          fi
          
          # Download hytale-downloader
          curl -sL https://downloader.hytale.com/hytale-downloader.zip -o hytale-downloader.zip
          unzip -q -o hytale-downloader.zip hytale-downloader-linux-amd64
          chmod +x hytale-downloader-linux-amd64
          
          # Create credentials file
          cat > /tmp/.hytale-credentials.json <<EOF
          {
            "access_token": "$ACCESS_TOKEN",
            "refresh_token": "",
            "expires_at": 2500000000,
            "branch": "release"
          }
          EOF
          
          # Get current version
          CURRENT_VERSION=$(./hytale-downloader-linux-amd64 --credentials-path /tmp/.hytale-credentials.json --print-version 2>&1 || echo "unknown")
          
          # Cleanup
          rm -f /tmp/.hytale-credentials.json hytale-downloader.zip hytale-downloader-linux-amd64
          
          echo "ðŸ“¦ Current Hytale version: $CURRENT_VERSION"
          
          # Get stored version from repository variables
          STORED_VERSION=$(gh variable get HYTALE_CURRENT_VERSION --repo ${{ github.repository }} 2>/dev/null || echo "")
          
          if [ -z "$STORED_VERSION" ]; then
            echo "ðŸ“ No stored version found, initializing..."
            gh variable set HYTALE_CURRENT_VERSION --body "$CURRENT_VERSION" --repo ${{ github.repository }}
            echo "version_changed=true" >> $GITHUB_OUTPUT
            echo "new_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
            echo "old_version=none" >> $GITHUB_OUTPUT
          elif [ "$STORED_VERSION" != "$CURRENT_VERSION" ]; then
            echo "ðŸ†• Version changed: $STORED_VERSION â†’ $CURRENT_VERSION"
            gh variable set HYTALE_CURRENT_VERSION --body "$CURRENT_VERSION" --repo ${{ github.repository }}
            echo "version_changed=true" >> $GITHUB_OUTPUT
            echo "new_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
            echo "old_version=$STORED_VERSION" >> $GITHUB_OUTPUT
          else
            echo "âœ… Version unchanged: $CURRENT_VERSION"
            echo "version_changed=false" >> $GITHUB_OUTPUT
            echo "new_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
            echo "old_version=$STORED_VERSION" >> $GITHUB_OUTPUT
          fi

      - name: Rebuild hytale-auth container
        if: inputs.force_rebuild || steps.check_version.outputs.version_changed == 'true' || (github.event_name == 'workflow_dispatch' && inputs.hytale_access_token != '')
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: hytale-auth.yml
          token: ${{ secrets.PAT_TOKEN }}
          ref: main

      - name: Summary
        run: |
          echo "## ðŸŽ® Hytale Authentication" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ github.event_name }}" == "schedule" ]; then
            echo "âœ… OAuth2 tokens refreshed automatically (scheduled run)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Next refresh:** 30 minutes from now" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ inputs.mode }}" == "device_code" ]; then
            echo "âœ… Initial authorization completed via Device Code Flow" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“ Tokens have been stored in GitHub Secrets" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Automatic refresh:** Every 30 minutes" >> $GITHUB_STEP_SUMMARY
          else
            echo "âœ… OAuth2 tokens refreshed successfully using refresh_token grant" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Version check info
          if [ -n "${{ steps.check_version.outputs.new_version }}" ]; then
            echo "### ðŸ“¦ Hytale Version Check" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Current version:** \`${{ steps.check_version.outputs.new_version }}\`" >> $GITHUB_STEP_SUMMARY
            
            if [ "${{ steps.check_version.outputs.version_changed }}" == "true" ]; then
              if [ "${{ steps.check_version.outputs.old_version }}" != "none" ]; then
                echo "**Previous version:** \`${{ steps.check_version.outputs.old_version }}\`" >> $GITHUB_STEP_SUMMARY
              fi
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "ðŸ†• **New version detected! Container rebuild triggered.**" >> $GITHUB_STEP_SUMMARY
            else
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "âœ… No version change" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ inputs.force_rebuild }}" == "true" ]; then
            echo "ðŸ”¨ Container rebuild triggered (forced)" >> $GITHUB_STEP_SUMMARY
          fi
